<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BRAWL SURVIVORS</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Courier+Prime:wght@400;700&display=swap');
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #000; font-family: 'Courier Prime', monospace; }
    canvas { display: block; cursor: crosshair; }

    /* --- HUD (Anime/Fighting game cyan style) --- */
    #hud {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none; z-index: 10; user-select: none;
    }
    #xp-bar-container {
      position: absolute; top: 0; left: 0; right: 0; height: 6px;
      background: rgba(0, 10, 20, 0.8); border-bottom: 1px solid #00ccff33;
    }
    #xp-bar {
      height: 100%; width: 0%;
      background: linear-gradient(90deg, #006688, #00ccff, #66eeff);
      transition: width 0.15s ease; box-shadow: 0 0 8px rgba(0,204,255,0.4);
    }
    #level-text {
      position: absolute; top: 8px; left: 50%; transform: translateX(-50%);
      color: #00ccff; font-size: 13px; font-weight: bold; font-family: 'Cinzel', serif;
      text-shadow: 0 0 6px rgba(0,204,255,0.3), 1px 1px 2px #000;
      letter-spacing: 2px;
    }
    #hud-bottom-center {
      position: absolute; bottom: 24px; left: 50%; transform: translateX(-50%);
      display: flex; align-items: center; gap: 12px;
    }
    #hp-bar-container {
      width: 280px; height: 14px; background: rgba(20, 10, 10, 0.85);
      border: 1px solid #8b0000; border-radius: 2px; position: relative; overflow: hidden;
    }
    #hp-bar {
      height: 100%; width: 100%;
      background: linear-gradient(90deg, #8b0000, #dc143c);
      transition: width 0.15s ease; box-shadow: inset 0 0 6px rgba(220,20,60,0.3);
    }
    #hp-text {
      position: absolute; top: 0; left: 50%; transform: translateX(-50%);
      color: #eee; font-size: 10px; font-weight: bold; line-height: 14px;
      text-shadow: 1px 1px 1px #000;
    }
    #dash-indicator {
      width: 32px; height: 32px; border-radius: 50%;
      border: 2px solid #00ccff; background: rgba(0,204,255,0.15);
      display: flex; align-items: center; justify-content: center;
      color: #00ccff; font-size: 11px; font-weight: bold; font-family: 'Cinzel', serif;
      transition: opacity 0.15s;
    }
    #dash-indicator.on-cooldown { opacity: 0.3; border-color: #333; color: #555; }
    #hud-top-right {
      position: absolute; top: 14px; right: 16px; text-align: right;
      color: #00ccffcc; font-size: 14px; font-family: 'Cinzel', serif;
      text-shadow: 1px 1px 2px #000;
    }
    #timer-text { font-size: 20px; font-weight: bold; color: #00ccffcc; }
    #kill-text { margin-top: 2px; font-size: 12px; color: #00ccff99; }

    /* Special move slots */
    #special-display {
      position: absolute; bottom: 24px; right: 20px;
      display: flex; gap: 6px; flex-direction: row;
    }
    .special-slot {
      width: 42px; height: 42px; background: rgba(0,10,20,0.7);
      border: 1px solid #00ccff44; border-radius: 3px;
      display: flex; align-items: center; justify-content: center;
      color: #00ccff; font-size: 12px; font-weight: bold;
      text-shadow: 0 0 4px rgba(0,204,255,0.3);
      position: relative; overflow: hidden;
      font-family: 'Cinzel', serif;
    }
    .special-slot.empty { opacity: 0.3; border-color: #333; color: #555; }
    .special-slot .cd-overlay {
      position: absolute; bottom: 0; left: 0; right: 0;
      background: rgba(0,0,0,0.7); transition: height 0.1s;
    }
    .special-slot .key-label {
      position: absolute; top: 1px; left: 3px; font-size: 9px; color: #00ccff88;
    }
    .special-slot .move-name {
      font-size: 8px; position: absolute; bottom: 1px; left: 0; right: 0;
      text-align: center; color: #00ccff66;
    }

    /* Combo counter */
    #combo-counter {
      position: fixed; top: 35%; left: 50%; transform: translateX(-50%);
      color: #00ccff; font-size: 48px; font-weight: bold;
      font-family: 'Cinzel', serif; text-shadow: 0 0 20px rgba(0,204,255,0.6), 0 0 40px rgba(0,204,255,0.3);
      pointer-events: none; z-index: 15; opacity: 0;
      transition: opacity 0.15s; letter-spacing: 3px;
    }
    #combo-counter.visible { opacity: 1; }
    #combo-counter.fading { opacity: 0; transition: opacity 0.5s; }

    /* --- SCREENS --- */
    .screen-overlay {
      position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
      z-index: 20; background: rgba(2, 5, 12, 0.92);
    }
    .screen-content {
      text-align: center; color: #eee; max-width: 620px; padding: 40px;
    }
    .screen-content h1 {
      font-size: 48px; margin-bottom: 8px; letter-spacing: 8px;
      font-family: 'Cinzel', serif; font-weight: 700;
      color: #00ccff; text-shadow: 0 0 30px rgba(0,204,255,0.3);
    }
    .screen-content .subtitle {
      font-size: 14px; color: #00ccff66; letter-spacing: 4px;
      font-family: 'Cinzel', serif; margin-bottom: 24px;
    }
    .screen-content h2 {
      font-size: 28px; margin-bottom: 16px; font-family: 'Cinzel', serif;
      color: #00ccff; text-shadow: 0 0 20px rgba(0,204,255,0.3);
    }
    .screen-content p { font-size: 14px; color: #8899aa; margin-bottom: 6px; line-height: 1.6; }
    .screen-content .stat { font-size: 18px; color: #00ccff; margin: 4px 0; font-family: 'Cinzel', serif; }
    .btn {
      display: inline-block; margin-top: 28px; padding: 12px 44px;
      background: transparent; color: #00ccff; border: 1px solid #00ccff;
      font-family: 'Cinzel', serif; font-size: 16px; font-weight: 700;
      letter-spacing: 3px; cursor: pointer; border-radius: 2px;
      transition: all 0.2s; pointer-events: auto; text-transform: uppercase;
    }
    .btn:hover { background: rgba(0,204,255,0.1); border-color: #66eeff; box-shadow: 0 0 15px rgba(0,204,255,0.15); }

    /* --- LEVEL UP --- */
    #levelup-screen .screen-content h2 { color: #00ccff; }
    #levelup-choices {
      display: flex; gap: 14px; justify-content: center; margin-top: 20px; flex-wrap: wrap;
    }
    .upgrade-card {
      width: 175px; padding: 18px 14px; background: rgba(2, 8, 18, 0.95);
      border: 1px solid #00ccff44; border-radius: 4px; cursor: pointer;
      transition: border-color 0.2s, transform 0.15s, box-shadow 0.2s;
      pointer-events: auto;
    }
    .upgrade-card:hover {
      border-color: #00ccff; transform: translateY(-3px);
      box-shadow: 0 0 20px rgba(0,204,255,0.15);
    }
    .upgrade-card h3 { font-size: 14px; color: #00ccff; margin-bottom: 6px; font-family: 'Cinzel', serif; }
    .upgrade-card .upgrade-icon { font-size: 24px; margin-bottom: 6px; color: #00ccff; }
    .upgrade-card p { font-size: 11px; color: #778899; line-height: 1.4; }

    /* --- LOADING --- */
    #loading-screen {
      position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
      flex-direction: column; z-index: 30; background: #020510;
      color: #00ccff; font-size: 18px; letter-spacing: 6px; font-family: 'Cinzel', serif;
    }
    .loading-dots::after { content: ''; animation: dots 1.5s infinite; }
    @keyframes dots { 0%,20%{content:'.'} 40%{content:'..'} 60%,100%{content:'...'} }

    /* --- DAMAGE NUMBERS --- */
    .damage-number {
      position: fixed; color: #00ccff; font-size: 13px; font-weight: bold;
      pointer-events: none; z-index: 15; font-family: 'Cinzel', serif;
      text-shadow: 0 0 4px rgba(0,204,255,0.4), 1px 1px 2px #000;
      animation: dmg-float 0.7s ease-out forwards;
    }
    .damage-number.big {
      font-size: 18px; color: #ffd700;
      text-shadow: 0 0 6px rgba(255,215,0,0.5), 1px 1px 2px #000;
    }
    @keyframes dmg-float { 0%{opacity:1;transform:translateY(0)} 100%{opacity:0;transform:translateY(-35px)} }

    /* --- SCREEN EFFECTS --- */
    #screen-flash {
      position: fixed; inset: 0; pointer-events: none; z-index: 12;
      background: radial-gradient(ellipse at center, transparent 50%, rgba(100,0,0,0.4) 100%);
      opacity: 0; transition: opacity 0.1s;
    }
    #screen-flash.cyan {
      background: radial-gradient(ellipse at center, rgba(0,204,255,0.15) 0%, transparent 60%);
    }
  </style>
</head>
<body>
  <div id="loading-screen"><span>LOADING<span class="loading-dots"></span></span></div>
  <div id="screen-flash"></div>
  <div id="combo-counter"></div>

  <div id="hud" style="display:none;">
    <div id="xp-bar-container"><div id="xp-bar"></div></div>
    <span id="level-text">LEVEL 1</span>
    <div id="hud-bottom-center">
      <div id="dash-indicator">D</div>
      <div id="hp-bar-container"><div id="hp-bar"></div><span id="hp-text">100/100</span></div>
    </div>
    <div id="hud-top-right">
      <div id="timer-text">00:00</div>
      <div id="kill-text">0 Kills</div>
    </div>
    <div id="special-display">
      <div class="special-slot empty" id="slot-0"><span class="key-label">Q</span><span class="move-name">---</span></div>
      <div class="special-slot empty" id="slot-1"><span class="key-label">E</span><span class="move-name">---</span></div>
      <div class="special-slot empty" id="slot-2"><span class="key-label">R</span><span class="move-name">---</span></div>
      <div class="special-slot empty" id="slot-3"><span class="key-label">F</span><span class="move-name">---</span></div>
    </div>
  </div>

  <div id="start-screen" class="screen-overlay" style="display:none;">
    <div class="screen-content">
      <h1>BRAWL SURVIVORS</h1>
      <div class="subtitle">STREET FIGHTER MEETS VAMPIRE SURVIVORS</div>
      <p>WASD — Move &nbsp; SPACE/SHIFT — Dash</p>
      <p>AIM with mouse &nbsp; LEFT CLICK — Combo Attack</p>
      <p>Q E R F — Special Moves</p>
      <button class="btn" id="start-btn">FIGHT</button>
    </div>
  </div>

  <div id="levelup-screen" class="screen-overlay" style="display:none;">
    <div class="screen-content">
      <h2>POWER UP!</h2>
      <p style="color:#778899;">Choose a power</p>
      <div id="levelup-choices"></div>
    </div>
  </div>

  <div id="gameover-screen" class="screen-overlay" style="display:none;">
    <div class="screen-content">
      <h2>K.O.</h2>
      <p class="stat" id="go-time"></p>
      <p class="stat" id="go-level"></p>
      <p class="stat" id="go-kills"></p>
      <button class="btn" id="restart-btn">FIGHT AGAIN</button>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { GammaCorrectionShader } from 'three/addons/shaders/GammaCorrectionShader.js';

    // ===============================================================
    // CONFIGURATION
    // ===============================================================
    const CONFIG = {
      PLAYER_SPEED: 5.5,
      PLAYER_MAX_HP: 100,
      PLAYER_PICKUP_RANGE: 2.0,
      PLAYER_INVINCIBLE_TIME: 0.25,
      DASH_SPEED_MULT: 3.5,
      DASH_DURATION: 0.15,
      DASH_COOLDOWN: 0.8,
      COMBO_WINDOW: 0.5,

      ENEMIES: {
        thug: {
          speed: 1.8, hp: 4, damage: 8, xp: 1, size: 1.0,
          texture: 'thugIdle',
          wobbleSpeed: 2, wobbleAmt: 0.05, shadowSize: 0.45
        },
        brawler: {
          speed: 1.2, hp: 10, damage: 15, xp: 2, size: 1.3,
          texture: 'brawlerIdle',
          wobbleSpeed: 1, wobbleAmt: 0.04, shadowSize: 0.55
        },
        ninja: {
          speed: 4.5, hp: 2, damage: 6, xp: 1, size: 0.8,
          texture: 'ninjaIdle',
          wobbleSpeed: 8, wobbleAmt: 0.03, shadowSize: 0.3
        },
      },

      BASIC_ATTACKS: {
        jab:        { damage: 5, range: 1.8, arc: Math.PI * 0.5, knockback: 0.2, sprite: 'fighterPunch', animTime: 0.1 },
        cross:      { damage: 8, range: 2.0, arc: Math.PI * 0.6, knockback: 0.3, sprite: 'fighterPunch', animTime: 0.12 },
        roundhouse: { damage: 14, range: 2.5, arc: Math.PI * 0.8, knockback: 0.8, sprite: 'fighterKick', animTime: 0.15 },
      },

      SPECIAL_MOVES: {
        hadouken:      { damage: 15, cooldown: 2.0, speed: 14, pierce: 3, sprite: 'fighterHadouken', name: 'Hadouken' },
        shoryuken:     { damage: 25, cooldown: 3.0, dashDist: 3, arc: Math.PI * 0.5, range: 2.0, invincTime: 0.2, sprite: 'fighterShoryuken', name: 'Shoryuken' },
        tatsumaki:     { damage: 8, cooldown: 4.0, radius: 2.5, duration: 0.5, hits: 4, sprite: 'fighterSpin', name: 'Tatsumaki' },
        lightningFist: { damage: 30, cooldown: 5.0, splashRadius: 2.0, sprite: 'fighterPunch', name: 'Lightning Fist' },
      },

      SPAWN_DISTANCE: 16,
      INITIAL_SPAWN_RATE: 1.4,
      MIN_SPAWN_RATE: 0.15,
      SPAWN_RATE_DECAY: 0.97,
      BASE_XP_TO_LEVEL: 5,
      XP_SCALE_FACTOR: 1.35,
      MAX_ENEMIES: 300,
      MAX_PROJECTILES: 200,
      MAX_XP_GEMS: 400,
      ARENA_SIZE: 40,
    };

    // Inline Vignette Shader
    const VignetteShader = {
      uniforms: { tDiffuse: { value: null }, offset: { value: 0.95 }, darkness: { value: 0.6 } },
      vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
      fragmentShader: `uniform sampler2D tDiffuse; uniform float offset; uniform float darkness; varying vec2 vUv;
        void main(){ vec4 c=texture2D(tDiffuse,vUv); vec2 u=vUv*2.0-1.0; float d=1.0-smoothstep(offset-0.2,offset,length(u));
        c.rgb*=mix(1.0,d,darkness); gl_FragColor=c; }`
    };

    // ===============================================================
    // THREE.JS SETUP
    // ===============================================================
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x0a0a1a);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 14, 12);
    camera.lookAt(0, 0, 0);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a0a1a, 0.018);
    const clock = new THREE.Clock();

    // Post-processing
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight), 0.5, 0.35, 0.78
    );
    composer.addPass(bloomPass);
    const vignettePass = new ShaderPass(VignetteShader);
    composer.addPass(vignettePass);
    composer.addPass(new ShaderPass(GammaCorrectionShader));

    window.addEventListener('resize', () => {
      const w = window.innerWidth, h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
      composer.setSize(w, h);
    });

    // ===============================================================
    // LIGHTING
    // ===============================================================
    const ambientLight = new THREE.AmbientLight(0xccddff, 0.3);
    scene.add(ambientLight);

    const keyLight = new THREE.DirectionalLight(0xffffff, 0.7);
    keyLight.position.set(8, 15, 8);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.set(2048, 2048);
    keyLight.shadow.camera.left = -30; keyLight.shadow.camera.right = 30;
    keyLight.shadow.camera.top = 30; keyLight.shadow.camera.bottom = -30;
    keyLight.shadow.bias = -0.001;
    keyLight.shadow.normalBias = 0.02;
    scene.add(keyLight); scene.add(keyLight.target);

    const fillLight = new THREE.DirectionalLight(0x667799, 0.25);
    fillLight.position.set(-5, 8, -5);
    scene.add(fillLight);

    const playerLight = new THREE.PointLight(0x00ccff, 0.5, 10);
    playerLight.position.set(0, 1.5, 0);
    scene.add(playerLight);

    // ===============================================================
    // SPRITE LOADING (chroma key)
    // ===============================================================
    function loadSpriteTexture(url, chromaKey = { r: 255, g: 0, b: 255 }, tolerance = 80) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          const canvas = document.createElement('canvas');
          canvas.width = img.width; canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const d = imageData.data; const w = canvas.width; const h = canvas.height;
          // Pass 1: magenta removal
          for (let i = 0; i < d.length; i += 4) {
            if (Math.abs(d[i] - chromaKey.r) < tolerance && Math.abs(d[i+1] - chromaKey.g) < tolerance && Math.abs(d[i+2] - chromaKey.b) < tolerance) d[i+3] = 0;
          }
          // Pass 2: flood-fill edges for gray backgrounds
          const isSat = (i) => { const mx = Math.max(d[i], d[i+1], d[i+2]), mn = Math.min(d[i], d[i+1], d[i+2]); return mx === 0 ? false : (mx - mn) / mx < 0.2 && d[i+3] > 0; };
          const vis = new Uint8Array(w * h); const q = [];
          for (let x = 0; x < w; x++) { q.push(x); q.push((h - 1) * w + x); }
          for (let y = 0; y < h; y++) { q.push(y * w); q.push(y * w + w - 1); }
          while (q.length) { const idx = q.pop(); if (idx < 0 || idx >= w * h || vis[idx]) continue; vis[idx] = 1; const pi = idx * 4;
            if (d[pi+3] === 0 || isSat(pi)) { d[pi+3] = 0; const x = idx % w, y = Math.floor(idx / w);
            if (x > 0) q.push(idx - 1); if (x < w - 1) q.push(idx + 1); if (y > 0) q.push(idx - w); if (y < h - 1) q.push(idx + w); } }
          ctx.putImageData(imageData, 0, 0);
          const texture = new THREE.CanvasTexture(canvas);
          texture.magFilter = THREE.NearestFilter; texture.minFilter = THREE.NearestFilter;
          texture.colorSpace = THREE.SRGBColorSpace;
          resolve(texture);
        };
        img.onerror = () => reject(new Error('Failed: ' + url));
        img.src = url;
      });
    }

    function loadTexSimple(url) {
      return new Promise((resolve, reject) => {
        new THREE.TextureLoader().load(url, (t) => {
          t.magFilter = THREE.NearestFilter; t.minFilter = THREE.NearestFilter;
          t.colorSpace = THREE.SRGBColorSpace; resolve(t);
        }, undefined, reject);
      });
    }

    function fallbackTex(color, sz = 64) {
      const c = document.createElement('canvas'); c.width = sz; c.height = sz;
      const x = c.getContext('2d'); x.fillStyle = color;
      x.beginPath(); x.arc(sz / 2, sz / 2, sz / 2 - 8, 0, Math.PI * 2); x.fill();
      const t = new THREE.CanvasTexture(c); t.magFilter = THREE.NearestFilter; t.minFilter = THREE.NearestFilter; return t;
    }

    // ===============================================================
    // SPRITE ANIMATOR
    // ===============================================================
    class SpriteAnimator {
      constructor(texture, cols, rows, frameCount, fps = 8) {
        this.texture = texture; this.cols = cols; this.rows = rows;
        this.frameCount = frameCount || (cols * rows); this.fps = fps;
        this.currentFrame = 0; this.timer = 0; this.playing = false;
        this.texture.wrapS = THREE.ClampToEdgeWrapping;
        this.texture.wrapT = THREE.ClampToEdgeWrapping;
        this.texture.repeat.set(1 / cols, 1 / rows);
        this._setFrame(0);
      }
      _setFrame(f) { const c = f % this.cols, r = Math.floor(f / this.cols); this.texture.offset.set(c / this.cols, 1 - (r + 1) / this.rows); }
      play() { this.playing = true; }
      stop() { this.playing = false; this._setFrame(0); this.currentFrame = 0; }
      reset() { this.currentFrame = 0; this.timer = 0; this._setFrame(0); }
      update(dt) {
        if (!this.playing) return; this.timer += dt;
        const fd = 1 / this.fps; if (this.timer >= fd) { this.timer -= fd;
        this.currentFrame = (this.currentFrame + 1) % this.frameCount; this._setFrame(this.currentFrame); }
      }
    }

    // ===============================================================
    // ASSET MANAGER
    // ===============================================================
    const Assets = { textures: {}, materials: {},
      async loadAll() {
        const sprites = [
          ['fighterIdle', 'sprites/fighter-idle.png', '#48f'],
          ['fighterPunch', 'sprites/fighter-punch.png', '#48f'],
          ['fighterKick', 'sprites/fighter-kick.png', '#48f'],
          ['fighterHadouken', 'sprites/fighter-hadouken.png', '#48f'],
          ['fighterShoryuken', 'sprites/fighter-shoryuken.png', '#48f'],
          ['fighterSpin', 'sprites/fighter-spin.png', '#48f'],
          ['thugIdle', 'sprites/thug-idle.png', '#844'],
          ['thugWalk', 'sprites/thug-walk.png', '#844'],
          ['brawlerIdle', 'sprites/brawler-idle.png', '#864'],
          ['brawlerWalk', 'sprites/brawler-walk.png', '#864'],
          ['ninjaIdle', 'sprites/ninja-idle.png', '#448'],
          ['ninjaWalk', 'sprites/ninja-walk.png', '#448'],
          ['hadoukenBall', 'sprites/hadouken-ball.png', '#0cf'],
          ['energyBurst', 'sprites/energy-burst.png', '#0cf'],
          ['xpGem', 'sprites/xp-gem-iso.png', '#4af'],
          ['propBarrel', 'sprites/prop-barrel.png', '#844'],
        ];
        const ps = sprites.map(async ([k, u, fb]) => {
          try { this.textures[k] = await loadSpriteTexture(u); }
          catch (e) { this.textures[k] = fallbackTex(fb); }
        });
        const gp = (async () => {
          try { this.textures.ground = await loadTexSimple('sprites/ground-urban.png'); }
          catch (e) {
            const c = document.createElement('canvas'); c.width = 128; c.height = 128; const x = c.getContext('2d');
            x.fillStyle = '#1a1a2a'; x.fillRect(0, 0, 128, 128);
            x.fillStyle = '#222233';
            for (let i = 0; i < 30; i++) x.fillRect(Math.random() * 128, Math.random() * 128, 6, 2);
            x.strokeStyle = '#2a2a3a'; x.lineWidth = 1;
            for (let i = 0; i <= 8; i++) { x.beginPath(); x.moveTo(i * 16, 0); x.lineTo(i * 16, 128); x.stroke(); x.beginPath(); x.moveTo(0, i * 16); x.lineTo(128, i * 16); x.stroke(); }
            this.textures.ground = new THREE.CanvasTexture(c); this.textures.ground.magFilter = THREE.NearestFilter;
          }
          this.textures.ground.wrapS = THREE.RepeatWrapping; this.textures.ground.wrapT = THREE.RepeatWrapping;
        })();
        await Promise.all([...ps, gp]);
      }
    };

    // ===============================================================
    // BILLBOARD SPRITE HELPERS
    // ===============================================================
    const billboardGeo = new THREE.PlaneGeometry(1, 1);
    billboardGeo.translate(0, 0.5, 0);

    function createBillboard(texture, w, h, emissiveColor = 0x000000, emissiveIntensity = 0.0) {
      const mat = new THREE.MeshStandardMaterial({
        map: texture, transparent: true, alphaTest: 0.1,
        side: THREE.DoubleSide, depthWrite: true,
        roughness: 0.9, metalness: 0.0,
        emissive: new THREE.Color(emissiveColor), emissiveIntensity: emissiveIntensity,
      });
      const mesh = new THREE.Mesh(billboardGeo, mat);
      mesh.scale.set(w, h, 1);
      mesh.castShadow = true;
      return mesh;
    }

    // Cylindrical billboard: rotate around Y only, stays upright on ground
    const _bbCamFlat = new THREE.Vector3();
    function cylBillboard(mesh) {
      _bbCamFlat.set(camera.position.x, mesh.position.y, camera.position.z);
      mesh.lookAt(_bbCamFlat);
    }

    // Drop shadow on ground
    const shadowGeo = new THREE.CircleGeometry(1, 16);
    shadowGeo.rotateX(-Math.PI / 2);
    const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.35, depthWrite: false });

    function createDropShadow(radius) {
      const s = new THREE.Mesh(shadowGeo, shadowMat.clone());
      s.scale.set(radius, 1, radius);
      s.position.y = 0.02;
      s.renderOrder = -1;
      return s;
    }

    // ===============================================================
    // GAME STATE
    // ===============================================================
    const game = {
      state: 'loading', elapsed: 0, spawnTimer: 0, spawnRate: CONFIG.INITIAL_SPAWN_RATE,
      comboHitCount: 0, comboDisplayTimer: 0, basicDamageMult: 1.0,
      player: {
        mesh: null, shadow: null, position: new THREE.Vector3(),
        hp: CONFIG.PLAYER_MAX_HP, maxHp: CONFIG.PLAYER_MAX_HP,
        level: 1, xp: 0, xpToNext: CONFIG.BASE_XP_TO_LEVEL,
        speed: CONFIG.PLAYER_SPEED, kills: 0, invincibleTimer: 0,
        facingRight: true, pickupRange: CONFIG.PLAYER_PICKUP_RANGE,
        // Dash
        dashTimer: 0, dashCooldown: 0, isDashing: false,
        dashDir: new THREE.Vector3(), lastMoveDir: new THREE.Vector3(0, 0, -1),
        // Mouse
        mouseGround: new THREE.Vector3(),
        aimDir: new THREE.Vector3(0, 0, -1),
        mouseNDC: new THREE.Vector2(),
        // Combo
        comboStep: 0, comboTimer: 0,
        attackAnimTimer: 0, isAttacking: false,
        // Specials
        specialMoves: [], // array of {type, level, cooldownMax}
        specialCooldowns: { hadouken: 0, shoryuken: 0, tatsumaki: 0, lightningFist: 0 },
        tatsumakiActive: false, tatsumakiTimer: 0, tatsumakiHitTimer: 0,
      },
      keys: {},
      enemies: [], projectiles: [], xpGems: [],
      enemyPool: [], projectilePool: [], xpGemPool: [],
      dashTrails: [],
      attackEffects: [],
      props: [],
      // Mouse
      mouseNDC: new THREE.Vector2(),
      raycaster: new THREE.Raycaster(),
      groundPlaneForRaycast: new THREE.Plane(new THREE.Vector3(0, 1, 0), 0),
      // Camera
      camTarget: new THREE.Vector3(),
      shakeIntensity: 0, shakeTimer: 0,
    };

    // ===============================================================
    // INPUT
    // ===============================================================
    window.addEventListener('keydown', (e) => {
      game.keys[e.code] = true;
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) e.preventDefault();
    });
    window.addEventListener('keyup', (e) => { game.keys[e.code] = false; });

    window.addEventListener('mousemove', (e) => {
      game.mouseNDC.x = (e.clientX / window.innerWidth) * 2 - 1;
      game.mouseNDC.y = -(e.clientY / window.innerHeight) * 2 + 1;
    });
    window.addEventListener('mousedown', (e) => {
      if (e.button === 0 && game.state === 'playing') playerComboAttack();
    });
    renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

    function updateMouseGround() {
      game.raycaster.setFromCamera(game.mouseNDC, camera);
      const target = new THREE.Vector3();
      game.raycaster.ray.intersectPlane(game.groundPlaneForRaycast, target);
      if (target) {
        game.player.mouseGround.copy(target);
        const dx = target.x - game.player.position.x;
        const dz = target.z - game.player.position.z;
        const len = Math.sqrt(dx * dx + dz * dz);
        if (len > 0.01) {
          game.player.aimDir.set(dx / len, 0, dz / len);
          game.player.facingRight = dx > 0;
        }
      }
    }

    function getInputDir() {
      const d = new THREE.Vector3(0, 0, 0);
      if (game.keys['KeyW'] || game.keys['ArrowUp']) d.z -= 1;
      if (game.keys['KeyS'] || game.keys['ArrowDown']) d.z += 1;
      if (game.keys['KeyA'] || game.keys['ArrowLeft']) d.x -= 1;
      if (game.keys['KeyD'] || game.keys['ArrowRight']) d.x += 1;
      if (d.lengthSq() > 0) d.normalize();
      return d;
    }

    // ===============================================================
    // BASIC COMBO ATTACK (Left Click)
    // ===============================================================
    const COMBO_NAMES = ['jab', 'cross', 'roundhouse'];

    function playerComboAttack() {
      const p = game.player;
      if (p.isAttacking) return;

      // If within combo window, advance
      if (p.comboTimer > 0 && p.comboStep < 2) {
        p.comboStep++;
      } else {
        p.comboStep = 0;
      }

      const atkName = COMBO_NAMES[p.comboStep];
      const cfg = CONFIG.BASIC_ATTACKS[atkName];
      p.comboTimer = CONFIG.COMBO_WINDOW;
      p.attackAnimTimer = cfg.animTime;
      p.isAttacking = true;

      // Swap sprite
      if (Assets.textures[cfg.sprite]) {
        p.mesh.material.map = Assets.textures[cfg.sprite];
        p.mesh.material.needsUpdate = true;
      }

      // Forward lunge
      p.position.x += p.aimDir.x * 0.3;
      p.position.z += p.aimDir.z * 0.3;

      const aimAngle = Math.atan2(p.aimDir.z, p.aimDir.x);
      const dmg = cfg.damage * game.basicDamageMult * getDifficultyDmgMult();
      let hitCount = 0;

      // Damage enemies in arc
      for (const e of game.enemies) {
        if (e.dying) continue;
        const dx = e.position.x - p.position.x;
        const dz = e.position.z - p.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        if (dist > cfg.range) continue;
        const angle = Math.atan2(dz, dx);
        let diff = angle - aimAngle;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;
        if (Math.abs(diff) < cfg.arc / 2) {
          damageEnemy(e, dmg, p.position, cfg.knockback);
          showDmgNum(e.position, dmg, dmg >= 10);
          hitCount++;
        }
      }

      if (hitCount > 0) {
        game.comboHitCount += hitCount;
        showComboCounter(game.comboHitCount);
      }

      // Spawn arc effect
      spawnArcEffect(p.position, aimAngle, cfg.range, cfg.arc);

      // Shake on roundhouse
      if (atkName === 'roundhouse') {
        triggerShake(0.12, 0.12);
      } else {
        triggerShake(0.04, 0.05);
      }

      // After roundhouse, combo resets
      if (p.comboStep === 2) {
        p.comboStep = 0;
        p.comboTimer = 0;
      }
    }

    function getDifficultyDmgMult() { return 1; }

    // ===============================================================
    // SPECIAL MOVES
    // ===============================================================
    const SPECIAL_KEYS = ['KeyQ', 'KeyE', 'KeyR', 'KeyF'];

    function checkSpecialInputs() {
      const p = game.player;
      for (let i = 0; i < 4; i++) {
        if (game.keys[SPECIAL_KEYS[i]] && p.specialMoves[i]) {
          game.keys[SPECIAL_KEYS[i]] = false; // consume
          const slot = p.specialMoves[i];
          const type = slot.type;
          if (p.specialCooldowns[type] <= 0) {
            activateSpecial(type, slot.level);
            p.specialCooldowns[type] = CONFIG.SPECIAL_MOVES[type].cooldown * Math.max(0.4, 1 - slot.level * 0.08);
          }
        }
      }
    }

    function activateSpecial(type, level) {
      const p = game.player;
      const cfg = CONFIG.SPECIAL_MOVES[type];
      const dmgMult = 1 + level * 0.25;

      // Cyan screen flash
      const flash = document.getElementById('screen-flash');
      flash.className = 'cyan';
      flash.style.opacity = '1';
      setTimeout(() => { flash.style.opacity = '0'; setTimeout(() => flash.className = '', 200); }, 100);

      if (type === 'hadouken') {
        // Sprite swap
        p.attackAnimTimer = 0.15;
        p.isAttacking = true;
        if (Assets.textures[cfg.sprite]) { p.mesh.material.map = Assets.textures[cfg.sprite]; p.mesh.material.needsUpdate = true; }

        // Fire projectile toward mouse
        const spawnPos = { x: p.position.x + p.aimDir.x * 0.8, y: 0, z: p.position.z + p.aimDir.z * 0.8 };
        spawnHadouken(spawnPos, { x: p.aimDir.x, z: p.aimDir.z }, cfg.damage * dmgMult, cfg.speed, cfg.pierce + Math.floor(level / 2));
        triggerShake(0.08, 0.1);
      }

      else if (type === 'shoryuken') {
        p.attackAnimTimer = 0.2;
        p.isAttacking = true;
        if (Assets.textures[cfg.sprite]) { p.mesh.material.map = Assets.textures[cfg.sprite]; p.mesh.material.needsUpdate = true; }
        p.invincibleTimer = Math.max(p.invincibleTimer, cfg.invincTime);

        // Dash forward
        const dashDist = cfg.dashDist + level * 0.3;
        p.position.x += p.aimDir.x * dashDist;
        p.position.z += p.aimDir.z * dashDist;

        // Damage enemies in cone at destination
        const aimAngle = Math.atan2(p.aimDir.z, p.aimDir.x);
        for (const e of game.enemies) {
          if (e.dying) continue;
          const dx = e.position.x - p.position.x;
          const dz = e.position.z - p.position.z;
          const dist = Math.sqrt(dx * dx + dz * dz);
          if (dist > cfg.range + level * 0.2) continue;
          const angle = Math.atan2(dz, dx);
          let diff = angle - aimAngle;
          while (diff > Math.PI) diff -= Math.PI * 2;
          while (diff < -Math.PI) diff += Math.PI * 2;
          if (Math.abs(diff) < cfg.arc / 2) {
            const dmg = cfg.damage * dmgMult;
            damageEnemy(e, dmg, p.position, 1.5);
            showDmgNum(e.position, dmg, true);
          }
        }

        // Energy column effect at destination
        spawnEnergyColumn(p.position);
        triggerShake(0.15, 0.15);
      }

      else if (type === 'tatsumaki') {
        p.attackAnimTimer = cfg.duration;
        p.isAttacking = true;
        if (Assets.textures[cfg.sprite]) { p.mesh.material.map = Assets.textures[cfg.sprite]; p.mesh.material.needsUpdate = true; }
        p.invincibleTimer = Math.max(p.invincibleTimer, cfg.duration + 0.05);
        p.tatsumakiActive = true;
        p.tatsumakiTimer = cfg.duration;
        p.tatsumakiHitTimer = 0;
        p._tatsumakiDmg = cfg.damage * dmgMult;
        p._tatsumakiRadius = cfg.radius + level * 0.2;
        p._tatsumakiHitInterval = cfg.duration / cfg.hits;

        // Spinning circle effect
        spawnSpinCircle(p.position, p._tatsumakiRadius, cfg.duration);
        triggerShake(0.1, cfg.duration);
      }

      else if (type === 'lightningFist') {
        // Teleport to mouse (clamped)
        const target = game.player.mouseGround.clone();
        const dx = target.x - p.position.x;
        const dz = target.z - p.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        const maxDist = 8;
        if (dist > maxDist) {
          target.x = p.position.x + (dx / dist) * maxDist;
          target.z = p.position.z + (dz / dist) * maxDist;
        }
        // Clamp to arena
        const arDist = Math.sqrt(target.x * target.x + target.z * target.z);
        if (arDist > CONFIG.ARENA_SIZE - 1) {
          target.x *= (CONFIG.ARENA_SIZE - 1) / arDist;
          target.z *= (CONFIG.ARENA_SIZE - 1) / arDist;
        }

        p.position.x = target.x;
        p.position.z = target.z;
        p.attackAnimTimer = 0.15;
        p.isAttacking = true;
        if (Assets.textures[cfg.sprite]) { p.mesh.material.map = Assets.textures[cfg.sprite]; p.mesh.material.needsUpdate = true; }
        p.invincibleTimer = Math.max(p.invincibleTimer, 0.2);

        // Splash damage at arrival
        const splashR = cfg.splashRadius + level * 0.2;
        for (const e of game.enemies) {
          if (e.dying) continue;
          const ex = e.position.x - target.x;
          const ez = e.position.z - target.z;
          if (ex * ex + ez * ez < splashR * splashR) {
            const dmg = cfg.damage * dmgMult;
            damageEnemy(e, dmg, target, 2.0);
            showDmgNum(e.position, dmg, true);
          }
        }

        // Energy burst
        spawnEnergyBurstEffect(target);
        triggerShake(0.2, 0.15);
      }
    }

    function updateTatsumaki(delta) {
      const p = game.player;
      if (!p.tatsumakiActive) return;
      p.tatsumakiTimer -= delta;
      p.tatsumakiHitTimer -= delta;
      if (p.tatsumakiHitTimer <= 0) {
        p.tatsumakiHitTimer = p._tatsumakiHitInterval;
        // Damage all in radius
        for (const e of game.enemies) {
          if (e.dying) continue;
          const dx = e.position.x - p.position.x;
          const dz = e.position.z - p.position.z;
          if (dx * dx + dz * dz < p._tatsumakiRadius * p._tatsumakiRadius) {
            damageEnemy(e, p._tatsumakiDmg, p.position, 0.5);
            showDmgNum(e.position, p._tatsumakiDmg, false);
          }
        }
      }
      if (p.tatsumakiTimer <= 0) {
        p.tatsumakiActive = false;
      }
    }

    function updateSpecialCooldowns(delta) {
      const p = game.player;
      for (const key of Object.keys(p.specialCooldowns)) {
        if (p.specialCooldowns[key] > 0) p.specialCooldowns[key] -= delta;
      }
    }

    // ===============================================================
    // PROJECTILES (Hadouken)
    // ===============================================================
    function spawnHadouken(origin, dir, damage, speed, pierce) {
      let p = game.projectilePool.pop(); if (!p) return;
      p.position.set(origin.x, 0.5, origin.z);
      p.velocity.set(dir.x * speed, 0, dir.z * speed);
      p.damage = damage; p.pierce = pierce; p.lifetime = 3.0; p.hitEnemies.clear();
      p.splashRadius = 0;
      const tex = Assets.textures.hadoukenBall;
      p.mesh.material.map = tex; p.mesh.material.needsUpdate = true;
      p.mesh.material.emissive.setHex(0x00ccff);
      p.mesh.material.emissiveIntensity = 2.0;
      p.mesh.scale.set(0.8, 0.8, 1);
      p.mesh.visible = true; p.mesh.position.copy(p.position);
      game.projectiles.push(p);
    }

    function createProjectilePool() {
      for (let i = 0; i < CONFIG.MAX_PROJECTILES; i++) {
        const mat = new THREE.MeshStandardMaterial({
          map: Assets.textures.hadoukenBall, transparent: true, alphaTest: 0.1,
          side: THREE.DoubleSide, emissive: new THREE.Color(0x00ccff), emissiveIntensity: 2.0,
          roughness: 0.5,
        });
        const mesh = new THREE.Mesh(billboardGeo, mat);
        mesh.scale.set(0.8, 0.8, 1); mesh.visible = false;
        scene.add(mesh);
        game.projectilePool.push({
          mesh, position: new THREE.Vector3(), velocity: new THREE.Vector3(),
          damage: 0, pierce: 0, lifetime: 0, hitEnemies: new Set(),
          splashRadius: 0,
        });
      }
    }

    function deactivateProjectile(p, i) { p.mesh.visible = false; game.projectiles.splice(i, 1); game.projectilePool.push(p); }

    function updateProjectiles(delta) {
      for (let i = game.projectiles.length - 1; i >= 0; i--) {
        const p = game.projectiles[i];
        p.position.addScaledVector(p.velocity, delta);
        p.mesh.position.copy(p.position);
        cylBillboard(p.mesh);
        p.lifetime -= delta;
        if (p.lifetime <= 0) { deactivateProjectile(p, i); continue; }
        for (const e of game.enemies) {
          if (e.dying) continue; if (p.hitEnemies.has(e)) continue;
          const dx = p.position.x - e.position.x, dz = p.position.z - e.position.z;
          if (dx * dx + dz * dz < 0.6) {
            damageEnemy(e, p.damage, p.position, 0.4);
            p.hitEnemies.add(e);
            showDmgNum(e.position, p.damage, p.damage >= 12);
            p.pierce--;
            if (p.pierce <= 0) { deactivateProjectile(p, i); break; }
          }
        }
      }
    }

    // ===============================================================
    // VISUAL EFFECTS
    // ===============================================================

    // Arc effect on ground plane for basic attacks
    function spawnArcEffect(origin, angle, range, arcWidth) {
      const halfArc = arcWidth / 2;
      const segments = 12;
      const verts = [0, 0, 0];
      for (let i = 0; i <= segments; i++) {
        const a = -halfArc + (i / segments) * halfArc * 2;
        verts.push(Math.cos(a) * range, 0, Math.sin(a) * range);
      }
      const indices = [];
      for (let i = 1; i <= segments; i++) indices.push(0, i, i + 1);
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
      geo.setIndex(indices);
      geo.computeVertexNormals();

      const mat = new THREE.MeshBasicMaterial({
        color: 0x00ccff, transparent: true, opacity: 0.5,
        side: THREE.DoubleSide, depthWrite: false,
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(origin.x, 0.08, origin.z);
      mesh.rotation.y = -angle;
      scene.add(mesh);
      game.attackEffects.push({ mesh, timer: 0.2, maxTimer: 0.2, type: 'ground' });
    }

    // Energy column for shoryuken
    function spawnEnergyColumn(pos) {
      const geo = new THREE.CylinderGeometry(0.3, 0.8, 4, 8, 1, true);
      const mat = new THREE.MeshBasicMaterial({
        color: 0x00ccff, transparent: true, opacity: 0.6,
        side: THREE.DoubleSide, depthWrite: false,
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(pos.x, 2, pos.z);
      scene.add(mesh);
      game.attackEffects.push({ mesh, timer: 0.35, maxTimer: 0.35, type: 'column' });

      // Ground circle
      const cGeo = new THREE.CircleGeometry(1.2, 24);
      cGeo.rotateX(-Math.PI / 2);
      const cMat = new THREE.MeshBasicMaterial({ color: 0x00ccff, transparent: true, opacity: 0.5, side: THREE.DoubleSide, depthWrite: false });
      const cMesh = new THREE.Mesh(cGeo, cMat);
      cMesh.position.set(pos.x, 0.08, pos.z);
      scene.add(cMesh);
      game.attackEffects.push({ mesh: cMesh, timer: 0.35, maxTimer: 0.35, type: 'ground' });
    }

    // Spinning circle for tatsumaki
    function spawnSpinCircle(pos, radius, duration) {
      const geo = new THREE.RingGeometry(radius * 0.3, radius, 24);
      geo.rotateX(-Math.PI / 2);
      const mat = new THREE.MeshBasicMaterial({
        color: 0x00ccff, transparent: true, opacity: 0.4,
        side: THREE.DoubleSide, depthWrite: false,
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(pos.x, 0.08, pos.z);
      scene.add(mesh);
      game.attackEffects.push({ mesh, timer: duration, maxTimer: duration, type: 'spin', owner: game.player });
    }

    // Energy burst for lightning fist
    function spawnEnergyBurstEffect(pos) {
      // Billboard burst
      const burstMat = new THREE.MeshBasicMaterial({
        map: Assets.textures.energyBurst, transparent: true, opacity: 0.9,
        side: THREE.DoubleSide, depthWrite: false,
      });
      const burstMesh = new THREE.Mesh(billboardGeo, burstMat);
      burstMesh.scale.set(3, 3, 1);
      burstMesh.position.set(pos.x, 0.8, pos.z);
      scene.add(burstMesh);
      game.attackEffects.push({ mesh: burstMesh, timer: 0.3, maxTimer: 0.3, type: 'billboard' });

      // Ground circle
      const cGeo = new THREE.CircleGeometry(2, 24);
      cGeo.rotateX(-Math.PI / 2);
      const cMat = new THREE.MeshBasicMaterial({ color: 0x00ccff, transparent: true, opacity: 0.6, side: THREE.DoubleSide, depthWrite: false });
      const cMesh = new THREE.Mesh(cGeo, cMat);
      cMesh.position.set(pos.x, 0.08, pos.z);
      scene.add(cMesh);
      game.attackEffects.push({ mesh: cMesh, timer: 0.4, maxTimer: 0.4, type: 'ground' });
    }

    function updateAttackEffects(delta) {
      for (let i = game.attackEffects.length - 1; i >= 0; i--) {
        const ef = game.attackEffects[i];
        ef.timer -= delta;
        const t = Math.max(0, ef.timer / ef.maxTimer);

        if (ef.type === 'billboard') {
          cylBillboard(ef.mesh);
          ef.mesh.material.opacity = t * 0.9;
          const expand = 1 + (1 - t) * 0.5;
          const baseS = 3;
          ef.mesh.scale.set(baseS * expand, baseS * expand, 1);
        } else if (ef.type === 'column') {
          ef.mesh.material.opacity = t * 0.6;
          ef.mesh.scale.y = 1 + (1 - t) * 0.3;
        } else if (ef.type === 'spin') {
          ef.mesh.material.opacity = t * 0.4;
          ef.mesh.rotation.y += delta * 12;
          // Follow player
          if (ef.owner) {
            ef.mesh.position.set(ef.owner.position.x, 0.08, ef.owner.position.z);
          }
        } else {
          // ground arc
          ef.mesh.material.opacity = t * 0.5;
          const expand = 1 + (1 - t) * 0.3;
          ef.mesh.scale.set(expand, 1, expand);
        }

        if (ef.timer <= 0) {
          scene.remove(ef.mesh);
          if (ef.mesh.geometry) ef.mesh.geometry.dispose();
          if (ef.mesh.material) ef.mesh.material.dispose();
          game.attackEffects.splice(i, 1);
        }
      }
    }

    // ===============================================================
    // COMBO COUNTER DISPLAY
    // ===============================================================
    let comboFadeTimeout = null;
    function showComboCounter(hits) {
      if (hits < 2) return;
      const el = document.getElementById('combo-counter');
      el.textContent = hits + ' HIT!';
      el.className = 'visible';
      game.comboDisplayTimer = 0.8;
      if (comboFadeTimeout) clearTimeout(comboFadeTimeout);
      comboFadeTimeout = setTimeout(() => {
        el.className = 'fading';
        setTimeout(() => { el.className = ''; }, 500);
      }, 800);
    }

    function updateComboDisplay(delta) {
      if (game.comboDisplayTimer > 0) {
        game.comboDisplayTimer -= delta;
      }
      // Reset combo hit counter if no attacks for a while
      const p = game.player;
      if (p.comboTimer <= 0 && !p.isAttacking && !p.tatsumakiActive) {
        if (game.comboHitCount > 0) {
          game.comboHitCount = 0;
        }
      }
    }

    // ===============================================================
    // GROUND & PROPS
    // ===============================================================
    function createGround() {
      const size = 100;
      const geo = new THREE.PlaneGeometry(size, size);
      geo.rotateX(-Math.PI / 2);
      const tex = Assets.textures.ground;
      tex.repeat.set(size / 3, size / 3);
      const mat = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.95, metalness: 0.05 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.receiveShadow = true;
      mesh.position.y = 0;
      scene.add(mesh);

      // Arena boundary ring (cyan)
      const ringGeo = new THREE.RingGeometry(CONFIG.ARENA_SIZE - 0.5, CONFIG.ARENA_SIZE, 64);
      ringGeo.rotateX(-Math.PI / 2);
      const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ccff, transparent: true, opacity: 0.15, side: THREE.DoubleSide });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.position.y = 0.03;
      scene.add(ring);
    }

    function createProps() {
      // 15 barrels scattered
      for (let i = 0; i < 15; i++) {
        const angle = (i / 15) * Math.PI * 2 + (Math.random() - 0.5) * 0.4;
        const r = 8 + Math.random() * 17;
        const px = Math.cos(angle) * r;
        const pz = Math.sin(angle) * r;

        const tex = Assets.textures.propBarrel;
        const mesh = createBillboard(tex, 1.0, 1.2);
        mesh.position.set(px, 0, pz);
        scene.add(mesh);

        const shadow = createDropShadow(0.5);
        shadow.position.set(px, 0.02, pz);
        scene.add(shadow);

        const prop = { mesh, position: new THREE.Vector3(px, 0, pz), radius: 0.5, type: 'barrel' };

        // Some barrels get a light
        if (i % 4 === 0) {
          const light = new THREE.PointLight(0x00ccff, 0.3, 5);
          light.position.set(px, 1.2, pz);
          scene.add(light);
          prop.light = light;
          prop.flickerOffset = Math.random() * Math.PI * 2;
        }

        game.props.push(prop);
      }
    }

    function updateProps(delta) {
      for (const prop of game.props) {
        cylBillboard(prop.mesh);
        if (prop.light) {
          prop.light.intensity = 0.25 + Math.sin(game.elapsed * 8 + prop.flickerOffset) * 0.12 + Math.random() * 0.05;
        }
      }
    }

    // ===============================================================
    // PLAYER
    // ===============================================================
    function createPlayer() {
      const mat = new THREE.MeshStandardMaterial({
        map: Assets.textures.fighterIdle, transparent: true, alphaTest: 0.1, side: THREE.DoubleSide,
        roughness: 0.8, metalness: 0.1, emissive: new THREE.Color(0x112244), emissiveIntensity: 0.1,
      });
      const mesh = new THREE.Mesh(billboardGeo, mat);
      mesh.scale.set(1.4, 1.8, 1);
      mesh.castShadow = true;
      scene.add(mesh);
      game.player.mesh = mesh;
      game.player.shadow = createDropShadow(0.5);
      scene.add(game.player.shadow);

      // Dash trail meshes (pool of 6)
      for (let i = 0; i < 6; i++) {
        const trailMat = new THREE.MeshBasicMaterial({
          map: Assets.textures.fighterIdle, transparent: true, opacity: 0, side: THREE.DoubleSide,
          color: 0x0088cc, depthWrite: false,
        });
        const trail = new THREE.Mesh(billboardGeo, trailMat);
        trail.scale.set(1.4, 1.8, 1);
        trail.visible = false;
        scene.add(trail);
        game.dashTrails.push({ mesh: trail, timer: 0, active: false });
      }
    }

    function updatePlayer(delta) {
      const p = game.player;
      const input = getInputDir();

      // Dash logic
      if ((game.keys['Space'] || game.keys['ShiftLeft'] || game.keys['ShiftRight']) && p.dashCooldown <= 0 && !p.isDashing) {
        p.isDashing = true;
        p.dashTimer = CONFIG.DASH_DURATION;
        p.dashCooldown = CONFIG.DASH_COOLDOWN;
        p.invincibleTimer = Math.max(p.invincibleTimer, CONFIG.DASH_DURATION + 0.05);
        p.dashDir.copy(input.lengthSq() > 0 ? input : p.lastMoveDir);
        spawnDashTrail();
      }

      if (p.isDashing) {
        p.dashTimer -= delta;
        p.position.x += p.dashDir.x * p.speed * CONFIG.DASH_SPEED_MULT * delta;
        p.position.z += p.dashDir.z * p.speed * CONFIG.DASH_SPEED_MULT * delta;
        if (p.dashTimer <= 0) p.isDashing = false;
      } else if (!p.tatsumakiActive) {
        p.position.x += input.x * p.speed * delta;
        p.position.z += input.z * p.speed * delta;
      }

      if (p.dashCooldown > 0) p.dashCooldown -= delta;
      if (input.lengthSq() > 0) p.lastMoveDir.copy(input);

      // Clamp circular arena
      const dist = Math.sqrt(p.position.x * p.position.x + p.position.z * p.position.z);
      if (dist > CONFIG.ARENA_SIZE - 1) {
        p.position.x *= (CONFIG.ARENA_SIZE - 1) / dist;
        p.position.z *= (CONFIG.ARENA_SIZE - 1) / dist;
      }

      // Prop collision
      for (const prop of game.props) {
        const dx = p.position.x - prop.position.x;
        const dz = p.position.z - prop.position.z;
        const d = Math.sqrt(dx * dx + dz * dz);
        if (d < prop.radius + 0.4 && d > 0.01) {
          const push = (prop.radius + 0.4 - d);
          p.position.x += (dx / d) * push;
          p.position.z += (dz / d) * push;
        }
      }

      // Walk animation (procedural bob)
      const isMoving = input.lengthSq() > 0 && !p.isDashing;
      let walkBob = 0;
      if (isMoving) {
        walkBob = Math.abs(Math.sin(game.elapsed * 10)) * 0.08;
        const squash = 1 - Math.abs(Math.sin(game.elapsed * 10)) * 0.04;
        const stretch = 1 + Math.abs(Math.sin(game.elapsed * 10)) * 0.04;
        p.mesh.scale.set((p.facingRight ? 1 : -1) * 1.4 * stretch, 1.8 * squash, 1);
      } else {
        const breath = 1 + Math.sin(game.elapsed * 2.5) * 0.02;
        p.mesh.scale.set((p.facingRight ? 1 : -1) * 1.4 * breath, 1.8 * breath, 1);
      }

      // Position
      p.mesh.position.set(p.position.x, walkBob, p.position.z);
      p.shadow.position.set(p.position.x, 0.02, p.position.z);
      p.shadow.scale.set(p.isDashing ? 0.3 : 0.5, 1, p.isDashing ? 0.3 : 0.5);

      // Billboard
      cylBillboard(p.mesh);

      // Mouse aim tracking
      updateMouseGround();

      // Check special inputs
      checkSpecialInputs();
      updateSpecialCooldowns(delta);
      updateTatsumaki(delta);

      // Combo timer
      if (p.comboTimer > 0) {
        p.comboTimer -= delta;
        if (p.comboTimer <= 0) {
          p.comboStep = 0;
        }
      }

      // Attack animation — swap texture back after timer
      if (p.attackAnimTimer > 0) {
        p.attackAnimTimer -= delta;
        if (p.attackAnimTimer <= 0) {
          p.mesh.material.map = Assets.textures.fighterIdle;
          p.mesh.material.needsUpdate = true;
          p.isAttacking = false;
        }
      }

      // Player light follows
      playerLight.position.set(p.position.x, 1.5, p.position.z);

      // Update directional light target to follow player
      keyLight.target.position.set(p.position.x, 0, p.position.z);
      keyLight.position.set(p.position.x + 8, 15, p.position.z + 8);

      // Invincibility
      if (p.invincibleTimer > 0) {
        p.invincibleTimer -= delta;
        p.mesh.visible = Math.floor(p.invincibleTimer * 12) % 2 === 0;
      } else { p.mesh.visible = true; }

      // Dash indicator
      const dashEl = document.getElementById('dash-indicator');
      if (p.dashCooldown > 0) dashEl.classList.add('on-cooldown');
      else dashEl.classList.remove('on-cooldown');

      // Dash trails update
      for (const t of game.dashTrails) {
        if (t.active) {
          t.timer -= delta;
          t.mesh.material.opacity = Math.max(0, t.timer / 0.3);
          cylBillboard(t.mesh);
          if (t.timer <= 0) { t.active = false; t.mesh.visible = false; }
        }
      }
    }

    function spawnDashTrail() {
      const p = game.player;
      let count = 0;
      for (const t of game.dashTrails) {
        if (!t.active && count < 3) {
          t.active = true; t.timer = 0.3;
          t.mesh.position.set(
            p.position.x - p.lastMoveDir.x * count * 0.4,
            0,
            p.position.z - p.lastMoveDir.z * count * 0.4
          );
          t.mesh.visible = true;
          t.mesh.material.opacity = 0.5;
          count++;
        }
      }
    }

    function damagePlayer(amount) {
      const p = game.player;
      if (p.invincibleTimer > 0) return;
      p.hp -= amount;
      p.invincibleTimer = CONFIG.PLAYER_INVINCIBLE_TIME;
      triggerShake(0.12, 0.12);
      // Red flash
      const flash = document.getElementById('screen-flash');
      flash.className = '';
      flash.style.opacity = '1';
      setTimeout(() => flash.style.opacity = '0', 100);
      if (p.hp <= 0) { p.hp = 0; gameOver(); }
    }

    // ===============================================================
    // CAMERA
    // ===============================================================
    function updateCamera(delta) {
      const p = game.player.position;
      game.camTarget.set(p.x, 14, p.z + 12);
      camera.position.lerp(game.camTarget, 0.06);
      camera.lookAt(p.x, 0, p.z);

      // Shake
      if (game.shakeTimer > 0) {
        game.shakeTimer -= delta;
        const s = game.shakeIntensity * (game.shakeTimer / 0.15);
        camera.position.x += (Math.random() - 0.5) * s;
        camera.position.y += (Math.random() - 0.5) * s * 0.5;
      }
    }

    function triggerShake(intensity, duration) { game.shakeIntensity = intensity; game.shakeTimer = duration; }

    // ===============================================================
    // ENEMY SYSTEM
    // ===============================================================
    function createEnemyPool() {
      for (let i = 0; i < CONFIG.MAX_ENEMIES; i++) {
        const tex = Assets.textures.thugWalk.clone();
        const mat = new THREE.MeshStandardMaterial({
          map: tex, transparent: true, alphaTest: 0.1, side: THREE.DoubleSide,
          roughness: 0.9, metalness: 0, emissive: 0x000000, emissiveIntensity: 0,
        });
        const mesh = new THREE.Mesh(billboardGeo, mat);
        mesh.castShadow = true; mesh.visible = false;
        scene.add(mesh);
        const shadow = createDropShadow(0.45);
        shadow.visible = false;
        scene.add(shadow);
        game.enemyPool.push({
          mesh, shadow, type: 'thug',
          hp: 0, maxHp: 0, speed: 0, damage: 0, xpValue: 0,
          position: new THREE.Vector3(), damageFlashTimer: 0,
          animator: null, wobbleOffset: Math.random() * Math.PI * 2,
          hitScaleTimer: 0, dying: false, deathTimer: 0, baseSize: 1,
        });
      }
    }

    function spawnEnemy(type, position) {
      let e = game.enemyPool.pop();
      if (!e) {
        if (game.enemies.length >= CONFIG.MAX_ENEMIES) return;
        const tex = Assets.textures[CONFIG.ENEMIES[type].texture];
        const mat = new THREE.MeshStandardMaterial({ map: tex, transparent: true, alphaTest: 0.1, side: THREE.DoubleSide, roughness: 0.9, metalness: 0 });
        const mesh = new THREE.Mesh(billboardGeo, mat); mesh.castShadow = true; scene.add(mesh);
        const shadow = createDropShadow(0.45); scene.add(shadow);
        e = { mesh, shadow, type, hp: 0, maxHp: 0, speed: 0, damage: 0, xpValue: 0, position: new THREE.Vector3(),
          damageFlashTimer: 0, animator: null, wobbleOffset: Math.random() * Math.PI * 2, hitScaleTimer: 0, dying: false, deathTimer: 0, baseSize: 1 };
      }
      const cfg = CONFIG.ENEMIES[type]; const diff = getDifficultyMult();
      e.type = type; e.hp = cfg.hp * diff; e.maxHp = e.hp;
      e.speed = cfg.speed * (1 + game.elapsed / 600); e.damage = cfg.damage * diff;
      e.xpValue = cfg.xp; e.position.copy(position);
      e.damageFlashTimer = 0; e.hitScaleTimer = 0; e.dying = false; e.deathTimer = 0;
      e.baseSize = cfg.size; e.wobbleOffset = Math.random() * Math.PI * 2;
      // Use idle texture (walk sheets have inconsistent grids from Gemini)
      e.mesh.material.map = Assets.textures[cfg.texture];
      e.mesh.material.needsUpdate = true;
      e.mesh.material.color.setHex(0xffffff); e.mesh.material.opacity = 1;
      e.mesh.material.emissiveIntensity = 0;
      e.animator = null; // Procedural animation only (wobble + bob)
      e.mesh.scale.set(cfg.size, cfg.size * 1.3, 1);
      e.mesh.position.set(position.x, 0, position.z);
      e.mesh.visible = true;
      e.shadow.position.set(position.x, 0.02, position.z);
      e.shadow.scale.set(cfg.shadowSize, 1, cfg.shadowSize);
      e.shadow.visible = true;
      game.enemies.push(e);
    }

    function deactivateEnemy(e, i) {
      e.mesh.visible = false; e.shadow.visible = false; e.mesh.position.y = 0;
      if (e.animator) e.animator.stop(); game.enemies.splice(i, 1); game.enemyPool.push(e);
    }

    function damageEnemy(e, dmg, srcPos, knockback) {
      if (e.dying) return;
      e.hp -= dmg; e.damageFlashTimer = 0.1; e.hitScaleTimer = 0.12;
      e.mesh.material.color.setHex(0xff4444);
      e.mesh.material.emissiveIntensity = 0.5;
      const kb = knockback || 0.25;
      if (srcPos) {
        const dx = e.position.x - srcPos.x, dz = e.position.z - srcPos.z;
        const d = Math.sqrt(dx * dx + dz * dz) || 1;
        e.position.x += (dx / d) * kb;
        e.position.z += (dz / d) * kb;
      }
    }

    function updateEnemies(delta) {
      const pp = game.player.position;
      for (let i = game.enemies.length - 1; i >= 0; i--) {
        const e = game.enemies[i]; const cfg = CONFIG.ENEMIES[e.type];
        // Death animation
        if (e.dying) {
          e.deathTimer -= delta; const t = 1 - e.deathTimer / 0.35;
          const shrink = Math.max(0, 1 - t);
          e.mesh.scale.set(e.baseSize * shrink, e.baseSize * 1.3 * shrink, 1);
          e.mesh.position.y = t * 1.5;
          e.mesh.material.opacity = shrink;
          e.shadow.scale.set(cfg.shadowSize * shrink, 1, cfg.shadowSize * shrink);
          cylBillboard(e.mesh);
          if (e.deathTimer <= 0) deactivateEnemy(e, i);
          continue;
        }
        // Move toward player (XZ plane)
        const dx = pp.x - e.position.x, dz = pp.z - e.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        if (dist > 0.1) { e.position.x += (dx / dist) * e.speed * delta; e.position.z += (dz / dist) * e.speed * delta; }
        // Separation
        for (let j = i - 1; j >= Math.max(0, i - 8); j--) {
          const o = game.enemies[j];
          const sx = e.position.x - o.position.x, sz = e.position.z - o.position.z, sd = sx * sx + sz * sz;
          if (sd < 0.5 && sd > 0.001) { const sep = 1 / Math.sqrt(sd) * 0.4 * delta; e.position.x += sx * sep; e.position.z += sz * sep; }
        }
        // Prop collision
        for (const prop of game.props) {
          const pdx = e.position.x - prop.position.x, pdz = e.position.z - prop.position.z;
          const pd = Math.sqrt(pdx * pdx + pdz * pdz);
          if (pd < prop.radius + 0.3 && pd > 0.01) { const push = (prop.radius + 0.3 - pd); e.position.x += (pdx / pd) * push; e.position.z += (pdz / pd) * push; }
        }
        // Sync mesh (with procedural walk bob)
        const walkBob = Math.abs(Math.sin(game.elapsed * 6 + e.wobbleOffset)) * 0.06;
        e.mesh.position.set(e.position.x, walkBob, e.position.z);
        e.shadow.position.set(e.position.x, 0.02, e.position.z);
        // Billboard
        cylBillboard(e.mesh);
        // Wobble
        const wobble = Math.sin(game.elapsed * (cfg.wobbleSpeed || 2) + e.wobbleOffset) * (cfg.wobbleAmt || 0.05);
        // Hit scale punch
        let sm = 1; if (e.hitScaleTimer > 0) { e.hitScaleTimer -= delta; sm = 1 + (e.hitScaleTimer / 0.12) * 0.2; }
        // Face + scale
        const fx = dx > 0 ? 1 : -1;
        e.mesh.scale.set(fx * e.baseSize * sm * (1 + wobble), e.baseSize * 1.3 * sm, 1);
        // Damage flash
        if (e.damageFlashTimer > 0) {
          e.damageFlashTimer -= delta;
          if (e.damageFlashTimer <= 0) { e.mesh.material.color.setHex(0xffffff); e.mesh.material.emissiveIntensity = 0; }
        }
        // Player collision (contact damage)
        if (dist < 0.7) damagePlayer(e.damage);
        // Death
        if (e.hp <= 0) {
          game.player.kills++; spawnXpGem(e.position, e.xpValue);
          e.dying = true; e.deathTimer = 0.35; if (e.animator) e.animator.stop();
        }
      }
    }

    function updateSpawning(delta) {
      game.spawnTimer -= delta;
      if (game.spawnTimer <= 0) {
        game.spawnTimer = game.spawnRate;
        const waveSize = Math.min(1 + Math.floor(game.elapsed / 20), 15);
        for (let i = 0; i < waveSize; i++) {
          const angle = Math.random() * Math.PI * 2;
          const d = CONFIG.SPAWN_DISTANCE + Math.random() * 3;
          const pos = new THREE.Vector3(
            game.player.position.x + Math.cos(angle) * d, 0,
            game.player.position.z + Math.sin(angle) * d
          );
          const r = Math.sqrt(pos.x * pos.x + pos.z * pos.z);
          if (r > CONFIG.ARENA_SIZE) { pos.x *= (CONFIG.ARENA_SIZE / r); pos.z *= (CONFIG.ARENA_SIZE / r); }
          const types = getEnemyTypes();
          spawnEnemy(types[Math.floor(Math.random() * types.length)], pos);
        }
        game.spawnRate = Math.max(CONFIG.MIN_SPAWN_RATE, game.spawnRate * CONFIG.SPAWN_RATE_DECAY);
      }
    }

    function getEnemyTypes() { const t = ['thug']; if (game.elapsed > 30) t.push('brawler'); if (game.elapsed > 60) t.push('ninja'); return t; }
    function getDifficultyMult() { return 1 + game.elapsed / 90; }

    // ===============================================================
    // XP GEM SYSTEM
    // ===============================================================
    function createXpGemPool() {
      for (let i = 0; i < CONFIG.MAX_XP_GEMS; i++) {
        const mat = new THREE.MeshStandardMaterial({
          map: Assets.textures.xpGem, transparent: true, alphaTest: 0.1,
          side: THREE.DoubleSide, emissive: new THREE.Color(0x0066ff), emissiveIntensity: 0.8,
        });
        const mesh = new THREE.Mesh(billboardGeo, mat);
        mesh.scale.set(0.4, 0.4, 1); mesh.visible = false;
        scene.add(mesh);
        game.xpGemPool.push({ mesh, position: new THREE.Vector3(), value: 1, magnetized: false, bobOff: Math.random() * Math.PI * 2 });
      }
    }

    function spawnXpGem(pos, val) {
      let g = game.xpGemPool.pop(); if (!g) return;
      g.position.set(pos.x + (Math.random() - 0.5) * 0.5, 0.3, pos.z + (Math.random() - 0.5) * 0.5);
      g.value = val; g.magnetized = false; g.bobOff = Math.random() * Math.PI * 2;
      g.mesh.visible = true; game.xpGems.push(g);
    }

    function deactivateGem(g, i) { g.mesh.visible = false; game.xpGems.splice(i, 1); game.xpGemPool.push(g); }

    function updateXpGems(delta) {
      const pp = game.player.position;
      const pr2 = game.player.pickupRange * game.player.pickupRange;
      const mr2 = (game.player.pickupRange * 3) * (game.player.pickupRange * 3);
      for (let i = game.xpGems.length - 1; i >= 0; i--) {
        const g = game.xpGems[i];
        const dx = pp.x - g.position.x, dz = pp.z - g.position.z, d2 = dx * dx + dz * dz;
        if (d2 < mr2) g.magnetized = true;
        if (g.magnetized && d2 > 0.01) { const d = Math.sqrt(d2); g.position.x += (dx / d) * 14 * delta; g.position.z += (dz / d) * 14 * delta; }
        if (d2 < pr2 * 0.15) { addXp(g.value); deactivateGem(g, i); continue; }
        g.position.y = 0.3 + Math.sin(game.elapsed * 3 + g.bobOff) * 0.1;
        g.mesh.position.copy(g.position);
        cylBillboard(g.mesh);
        const pulse = 1 + Math.sin(game.elapsed * 4 + g.bobOff) * 0.1;
        g.mesh.scale.set(0.4 * pulse, 0.4 * pulse, 1);
      }
    }

    // ===============================================================
    // XP / LEVELING
    // ===============================================================
    function addXp(amt) {
      game.player.xp += amt;
      while (game.player.xp >= game.player.xpToNext) {
        game.player.xp -= game.player.xpToNext; game.player.level++;
        game.player.xpToNext = Math.floor(CONFIG.BASE_XP_TO_LEVEL * Math.pow(CONFIG.XP_SCALE_FACTOR, game.player.level - 1));
        showLevelUp(); return;
      }
    }

    // ===============================================================
    // LEVEL-UP / UPGRADE SYSTEM
    // ===============================================================
    const ALL_SPECIAL_TYPES = ['hadouken', 'shoryuken', 'tatsumaki', 'lightningFist'];

    const SPECIAL_ICONS = {
      hadouken: '&#128293;',      // fire
      shoryuken: '&#9889;',       // lightning
      tatsumaki: '&#127744;',     // cyclone
      lightningFist: '&#9733;',   // star
    };

    const PASSIVE_UPGRADES = [
      { id: 'p_hp', name: 'Vitality', icon: '&#9829;', desc: '+25 Max HP',
        apply() { game.player.maxHp += 25; game.player.hp = Math.min(game.player.hp + 25, game.player.maxHp); } },
      { id: 'p_spd', name: 'Swiftness', icon: '&#9812;', desc: '+12% movement speed',
        apply() { game.player.speed *= 1.12; } },
      { id: 'p_mag', name: 'Magnetism', icon: '&#9883;', desc: '+50% pickup range',
        apply() { game.player.pickupRange *= 1.5; } },
      { id: 'p_heal', name: 'Restoration', icon: '&#10010;', desc: 'Heal 30 HP',
        apply() { game.player.hp = Math.min(game.player.hp + 30, game.player.maxHp); } },
      { id: 'p_fists', name: 'Iron Fists', icon: '&#9994;', desc: '+20% basic attack damage',
        apply() { game.basicDamageMult *= 1.2; } },
    ];

    function getLearnedTypes() {
      return game.player.specialMoves.map(s => s.type);
    }

    function getUnlearnedTypes() {
      const learned = getLearnedTypes();
      return ALL_SPECIAL_TYPES.filter(t => !learned.includes(t));
    }

    function showLevelUp() {
      game.state = 'levelup';
      const ct = document.getElementById('levelup-choices');
      ct.innerHTML = '';
      const p = game.player;

      // First level-up: choose first special
      if (p.specialMoves.length === 0) {
        document.querySelector('#levelup-screen h2').textContent = 'CHOOSE YOUR FIRST SPECIAL MOVE';
        // Pick 3 random specials from the 4
        const available = [...ALL_SPECIAL_TYPES];
        shuffle(available);
        const choices = available.slice(0, 3);
        for (const type of choices) {
          const cfg = CONFIG.SPECIAL_MOVES[type];
          const card = document.createElement('div');
          card.className = 'upgrade-card';
          card.innerHTML = `<div class="upgrade-icon">${SPECIAL_ICONS[type]}</div><h3>${cfg.name}</h3><p>Dmg: ${cfg.damage} | CD: ${cfg.cooldown}s</p>`;
          card.addEventListener('click', () => {
            p.specialMoves.push({ type, level: 1, cooldownMax: cfg.cooldown });
            p.specialCooldowns[type] = 0;
            document.getElementById('levelup-screen').style.display = 'none';
            game.state = 'playing'; clock.getDelta();
            updateSpecialDisplay();
          });
          ct.appendChild(card);
        }
      } else {
        // Subsequent level-ups
        document.querySelector('#levelup-screen h2').textContent = 'POWER UP!';
        const pool = [];

        // New special move (if < 4 slots, random from unlearned)
        const unlearned = getUnlearnedTypes();
        if (p.specialMoves.length < 4 && unlearned.length > 0) {
          const newType = unlearned[Math.floor(Math.random() * unlearned.length)];
          const cfg = CONFIG.SPECIAL_MOVES[newType];
          pool.push({
            name: cfg.name + ' (NEW)', icon: SPECIAL_ICONS[newType],
            desc: `Learn ${cfg.name}! Dmg: ${cfg.damage} | CD: ${cfg.cooldown}s`,
            apply() {
              p.specialMoves.push({ type: newType, level: 1, cooldownMax: cfg.cooldown });
              p.specialCooldowns[newType] = 0;
            }
          });
        }

        // Upgrade a learned special
        if (p.specialMoves.length > 0) {
          const slot = p.specialMoves[Math.floor(Math.random() * p.specialMoves.length)];
          const cfg = CONFIG.SPECIAL_MOVES[slot.type];
          pool.push({
            name: cfg.name + ' UP', icon: SPECIAL_ICONS[slot.type],
            desc: `Upgrade ${cfg.name} to Lv ${slot.level + 1} (+dmg, -cooldown)`,
            apply() { slot.level++; }
          });
        }

        // Passives - shuffle and pick to fill 3 options
        const passives = [...PASSIVE_UPGRADES];
        shuffle(passives);
        let idx = 0;
        while (pool.length < 3 && idx < passives.length) {
          const pa = passives[idx++];
          pool.push({ name: pa.name, icon: pa.icon, desc: pa.desc, apply: pa.apply });
        }

        // If we still don't have 3, add more upgrade options
        while (pool.length < 3 && p.specialMoves.length > 0) {
          const slot = p.specialMoves[Math.floor(Math.random() * p.specialMoves.length)];
          const cfg = CONFIG.SPECIAL_MOVES[slot.type];
          pool.push({
            name: cfg.name + ' UP', icon: SPECIAL_ICONS[slot.type],
            desc: `Upgrade ${cfg.name} to Lv ${slot.level + 1}`,
            apply() { slot.level++; }
          });
        }

        shuffle(pool);
        const choices = pool.slice(0, 3);
        for (const u of choices) {
          const card = document.createElement('div');
          card.className = 'upgrade-card';
          card.innerHTML = `<div class="upgrade-icon">${u.icon}</div><h3>${u.name}</h3><p>${u.desc}</p>`;
          card.addEventListener('click', () => {
            u.apply();
            document.getElementById('levelup-screen').style.display = 'none';
            game.state = 'playing'; clock.getDelta();
            updateSpecialDisplay();
          });
          ct.appendChild(card);
        }
      }
      document.getElementById('levelup-screen').style.display = 'flex';
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    // ===============================================================
    // HUD
    // ===============================================================
    let lastHud = 0;
    function updateHUD() {
      if (game.elapsed - lastHud < 0.08) return; lastHud = game.elapsed;
      const p = game.player;
      document.getElementById('xp-bar').style.width = ((p.xp / p.xpToNext) * 100) + '%';
      document.getElementById('level-text').textContent = 'LEVEL ' + p.level;
      document.getElementById('hp-bar').style.width = ((p.hp / p.maxHp) * 100) + '%';
      document.getElementById('hp-text').textContent = Math.ceil(p.hp) + '/' + p.maxHp;
      const m = Math.floor(game.elapsed / 60), s = Math.floor(game.elapsed % 60);
      document.getElementById('timer-text').textContent = String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0');
      document.getElementById('kill-text').textContent = p.kills + ' Kills';

      // Update special slot cooldown overlays
      for (let i = 0; i < 4; i++) {
        const slotEl = document.getElementById('slot-' + i);
        if (p.specialMoves[i]) {
          const slot = p.specialMoves[i];
          const cfg = CONFIG.SPECIAL_MOVES[slot.type];
          const cd = p.specialCooldowns[slot.type];
          const maxCd = cfg.cooldown * Math.max(0.4, 1 - slot.level * 0.08);
          slotEl.classList.remove('empty');

          // Update cooldown overlay
          let overlay = slotEl.querySelector('.cd-overlay');
          if (!overlay) {
            overlay = document.createElement('div');
            overlay.className = 'cd-overlay';
            slotEl.appendChild(overlay);
          }
          if (cd > 0) {
            overlay.style.height = Math.min(100, (cd / maxCd) * 100) + '%';
          } else {
            overlay.style.height = '0%';
          }
        }
      }
    }

    function updateSpecialDisplay() {
      const p = game.player;
      const keys = ['Q', 'E', 'R', 'F'];
      for (let i = 0; i < 4; i++) {
        const slotEl = document.getElementById('slot-' + i);
        if (p.specialMoves[i]) {
          const slot = p.specialMoves[i];
          const cfg = CONFIG.SPECIAL_MOVES[slot.type];
          slotEl.classList.remove('empty');
          slotEl.querySelector('.key-label').textContent = keys[i];
          slotEl.querySelector('.move-name').textContent = cfg.name.substring(0, 6);
        } else {
          slotEl.classList.add('empty');
          slotEl.querySelector('.key-label').textContent = keys[i];
          slotEl.querySelector('.move-name').textContent = '---';
        }
      }
    }

    function showDmgNum(pos, dmg, big) {
      const v = new THREE.Vector3(pos.x, pos.y || 0.5, pos.z); v.project(camera);
      const x = (v.x * 0.5 + 0.5) * window.innerWidth, y = (-v.y * 0.5 + 0.5) * window.innerHeight;
      const el = document.createElement('div'); el.className = 'damage-number';
      if (big) el.classList.add('big');
      el.textContent = Math.round(dmg); el.style.left = (x + (Math.random() - 0.5) * 16) + 'px'; el.style.top = (y - 10) + 'px';
      document.body.appendChild(el); setTimeout(() => el.remove(), 700);
    }

    // ===============================================================
    // GAME STATES
    // ===============================================================
    function startGame() {
      game.state = 'playing'; game.elapsed = 0; game.spawnTimer = 0;
      game.spawnRate = CONFIG.INITIAL_SPAWN_RATE; lastHud = 0;
      game.comboHitCount = 0; game.comboDisplayTimer = 0; game.basicDamageMult = 1.0;
      const p = game.player;
      p.hp = CONFIG.PLAYER_MAX_HP; p.maxHp = CONFIG.PLAYER_MAX_HP; p.level = 1; p.xp = 0;
      p.xpToNext = CONFIG.BASE_XP_TO_LEVEL; p.speed = CONFIG.PLAYER_SPEED; p.kills = 0;
      p.position.set(0, 0, 0); p.invincibleTimer = 0; p.pickupRange = CONFIG.PLAYER_PICKUP_RANGE;
      p.dashTimer = 0; p.dashCooldown = 0; p.isDashing = false;
      p.comboStep = 0; p.comboTimer = 0; p.attackAnimTimer = 0; p.isAttacking = false;
      p.specialMoves = [];
      p.specialCooldowns = { hadouken: 0, shoryuken: 0, tatsumaki: 0, lightningFist: 0 };
      p.tatsumakiActive = false; p.tatsumakiTimer = 0;
      p.mesh.material.map = Assets.textures.fighterIdle;
      p.mesh.material.needsUpdate = true;
      clearEntities();
      document.getElementById('hud').style.display = 'block';
      updateHUD(); updateSpecialDisplay(); clock.getDelta();
    }

    function clearEntities() {
      while (game.enemies.length) { const e = game.enemies.pop(); e.mesh.visible = false; e.shadow.visible = false;
        e.mesh.position.y = 0; if (e.animator) e.animator.stop(); game.enemyPool.push(e); }
      while (game.projectiles.length) { const p = game.projectiles.pop(); p.mesh.visible = false; game.projectilePool.push(p); }
      while (game.xpGems.length) { const g = game.xpGems.pop(); g.mesh.visible = false; game.xpGemPool.push(g); }
      for (const t of game.dashTrails) { t.active = false; t.mesh.visible = false; }
      for (const ef of game.attackEffects) { scene.remove(ef.mesh); if (ef.mesh.material) ef.mesh.material.dispose(); }
      game.attackEffects.length = 0;
    }

    function gameOver() {
      game.state = 'gameover';
      const m = Math.floor(game.elapsed / 60), s = Math.floor(game.elapsed % 60);
      document.getElementById('go-time').textContent = 'Survived: ' + String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0');
      document.getElementById('go-level').textContent = 'Level: ' + game.player.level;
      document.getElementById('go-kills').textContent = 'Kills: ' + game.player.kills;
      document.getElementById('gameover-screen').style.display = 'flex';
      document.getElementById('hud').style.display = 'none';
    }

    document.getElementById('start-btn').addEventListener('click', () => {
      document.getElementById('start-screen').style.display = 'none'; startGame();
    });
    document.getElementById('restart-btn').addEventListener('click', () => {
      document.getElementById('gameover-screen').style.display = 'none'; startGame();
    });

    // ===============================================================
    // MAIN LOOP
    // ===============================================================
    function gameLoop() {
      requestAnimationFrame(gameLoop);
      const delta = Math.min(clock.getDelta(), 0.05);

      if (game.state === 'playing') {
        game.elapsed += delta;
        updatePlayer(delta);
        updateSpawning(delta);
        updateEnemies(delta);
        updateProjectiles(delta);
        updateXpGems(delta);
        updateAttackEffects(delta);
        updateComboDisplay(delta);
        updateProps(delta);
        updateCamera(delta);
        updateHUD();
      } else {
        updateCamera(delta);
        updateProps(delta);
      }

      composer.render();
    }

    // ===============================================================
    // INIT
    // ===============================================================
    async function init() {
      try {
        await Assets.loadAll();
        createGround();
        createProps();
        createPlayer();
        createEnemyPool();
        createProjectilePool();
        createXpGemPool();

        document.getElementById('loading-screen').style.display = 'none';
        document.getElementById('start-screen').style.display = 'flex';
        game.state = 'start';
        gameLoop();
      } catch (err) {
        console.error('Init failed:', err);
        document.getElementById('loading-screen').innerHTML = '<span style="color:#a44;">Failed to load</span>';
      }
    }

    init();
  </script>
</body>
</html>
